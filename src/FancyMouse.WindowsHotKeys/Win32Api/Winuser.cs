using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;

namespace FancyMouse.WindowsHotKeys.Win32Api;

/// <summary>
///
/// </summary>
/// <remarks>
/// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/
///     https://github.com/MicrosoftDocs/sdk-api/tree/docs/sdk-api-src/content/winuser
/// </remarks>
[SuppressMessage("ReSharper", "FieldCanBeMadeReadOnly.Global")]
[SuppressMessage("ReSharper", "InconsistentNaming")]
[SuppressMessage("ReSharper", "MemberCanBePrivate.Global")]
[SuppressMessage("ReSharper", "UnusedMember.Global")]
internal static class Winuser
{

    #region Constants

    public const int HWND_MESSAGE = -3;

    public const uint CW_USEDEFAULT = 0x80000000;

    #endregion

    #region Learn / Windows / Apps / Win32 / Desktop Technologies / Accessibility / Windows Accessibility features
    // see https://learn.microsoft.com/en-us/windows/win32/winauto/about-windows-accessibility-features

    #region Windows Accessibility API Reference / Microsoft Active Accessibility / C/C++ Reference Active Accessibility User Interfaces Services / WM_GETOBJECT Window Message
    // see https://learn.microsoft.com/en-us/windows/win32/winauto/wm-getobject

    /// <summary>
    /// Sent by both Microsoft Active Accessibility and Microsoft UI Automation
    /// to obtain information about an accessible object contained in a server application.
    /// </summary>
    public const uint WM_GETOBJECT = 0x003d;

    #endregion

    #endregion

    #region Learn / Windows / Apps / Win32 / Desktop Technologies / Desktop App User Interface / Dialog Boxes
    // see https://learn.microsoft.com/en-us/windows/win32/dlgbox/dialog-boxes

    #region Dialog Box Reference / Dialog Box Notifications
    // see https://learn.microsoft.com/en-us/windows/win32/dlgbox/dialog-box-notifications

    /// <summary>
    /// Sent to a dialog box before the system draws the dialog box.
    /// By responding to this message, the dialog box can set its text
    /// and background colors using the specified display device context handle.
    /// </summary>
    public const uint WM_CTLCOLORDLG = 0x0136;

    /// <summary>
    /// Sent to the owner window of a modal dialog box or menu that is entering an idle state.
    /// A modal dialog box or menu enters an idle state when no messages are waiting in its
    /// queue after it has processed one or more previous messages.
    /// </summary>
    public const uint WM_ENTERIDLE = 0x0121;

    /// <summary>
    /// Sent to the window procedure associated with a control. By default, the system handles
    /// all keyboard input to the control; the system interprets certain types of keyboard
    /// input as dialog box navigation keys. To override this default behavior, the control
    /// can respond to the WM_GETDLGCODE message to indicate the types of input it wants to
    /// process itself.
    /// </summary>
    public const uint WM_GETDLGCODE = 0x0087;

    /// <summary>
    /// Sent to the dialog box procedure immediately before a dialog box is displayed.
    /// Dialog box procedures typically use this message to initialize controls and carry
    /// out any other initialization tasks that affect the appearance of the dialog box.
    /// </summary>
    public const uint WM_INITDIALOG = 0x0110;

    /// <summary>
    /// Sent to a dialog box procedure to set the keyboard focus to a different control
    /// in the dialog box.
    /// </summary>
    public const uint WM_NEXTDLGCTL = 0x0028;

    #endregion

    #endregion

    #region Learn / Windows / Apps / Win32 / Desktop Technologies / Desktop App User Interface / User Interaction / Legacy / Keyboard and Mouse Input
    // see https://learn.microsoft.com/en-us/windows/win32/inputdev/user-input

    #region Keyboard Input / Keyboard Input Reference / Keyboard Input Functions
    // see https://learn.microsoft.com/en-us/windows/win32/inputdev/keyboard-input-functions

    #region RegisterHotKey

    /// <summary>
    /// Defines a system-wide hot key.
    /// </summary>
    /// <param name="hWnd">
    /// A handle to the window that will receive WM_HOTKEY messages generated by the hot key
    /// If this parameter is NULL, WM_HOTKEY messages are posted to the message queue of the
    /// calling thread and must be processed in the message loop.
    /// </param>
    /// <param name="id">
    /// The identifier of the hot key. If the hWnd parameter is NULL, then the hot key is
    /// associated with the current thread rather than with a particular window. If a hot
    /// key already exists with the same hWnd and id parameters, see Remarks for the action
    /// taken.
    /// </param>
    /// <param name="fsModifiers">
    /// The keys that must be pressed in combination with the key specified by the uVirtKey
    /// parameter in order to generate the WM_HOTKEY message
    /// </param>
    /// <param name="vk">
    /// The virtual-key code of the hot key. See Virtual Key Codes.
    /// </param>
    /// <returns>
    /// If the function succeeds, the return value is nonzero.
    /// If the function fails, the return value is zero.
    /// To get extended error information, call GetLastError.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerhotkey
    /// </remarks>
    [DllImport("user32", SetLastError = true)]
    public static extern int RegisterHotKey(
        [In] IntPtr hWnd,
        [In] int id,
        [In] uint fsModifiers,
        [In] uint vk
    );

    /// <summary>
    /// Either ALT key must be held down.
    /// </summary>
    public const uint MOD_ALT = 0x0001;

    /// <summary>
    /// Either CTRL key must be held down.
    /// </summary>
    public const uint MOD_CONTROL = 0x0002;

    /// <summary>
    /// Changes the hotkey behavior so that the keyboard auto-repeat does not yield multiple hotkey notifications.
    /// </summary>
    public const uint MOD_NOREPEAT = 0x4000;

    /// <summary>
    /// Either SHIFT key must be held down.
    /// </summary>
    public const uint MOD_SHIFT = 0x0004;

    /// <summary>
    /// Either WINDOWS key was held down.
    /// These keys are labeled with the Windows logo.
    /// Keyboard shortcuts that involve the WINDOWS key are reserved for use by the operating system.
    /// </summary>
    public const uint MOD_WIN = 0x0008;

    #endregion

    /// <summary>
    /// Frees a hot key previously registered by the calling thread.
    /// </summary>
    /// <param name="hWnd">
    /// A handle to the window associated with the hot key to be freed.
    /// This parameter should be NULL if the hot key is not associated with a window.
    /// </param>
    /// <param name="id">
    /// The identifier of the hot key to be freed.
    /// </param>
    /// <returns>
    /// If the function succeeds, the return value is nonzero.
    /// If the function fails, the return value is zero.
    /// To get extended error information, call GetLastError.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unregisterhotkey
    /// </remarks>
    [DllImport("user32", SetLastError = true)]
    public static extern int UnregisterHotKey(
        IntPtr hWnd,
        int id
    );

    #endregion

    #region Keyboard Input / Keyboard Input Reference / Keyboard Input Notifications
    // see https://learn.microsoft.com/en-us/windows/win32/inputdev/keyboard-input-notifications

    /// <summary>
    /// Sent to both the window being activated and the window being deactivated. If the windows
    /// use the same input queue, the message is sent synchronously, first to the window procedure
    /// of the top-level window being deactivated, then to the window procedure of the top-level
    /// window being activated. If the windows use different input queues, the message is sent
    /// asynchronously, so the window is activated immediately.
    /// </summary>
    public const uint WM_ACTIVATE = 0x0006;

    /// <summary>
    /// Notifies a window that the user generated an application command event, for example, by
    /// clicking an application command button using the mouse or typing an application command
    /// key on the keyboard.
    /// </summary>
    public const uint WM_APPCOMMAND = 0x0319;

    /// <summary>
    /// Posted to the window with the keyboard focus when a WM_KEYDOWN message is translated by
    /// the TranslateMessage function. The WM_CHAR message contains the character code of the
    /// key that was pressed.
    /// </summary>
    public const uint WM_CHAR = 0x0102;

    /// <summary>
    /// Posted to the window with the keyboard focus when a WM_KEYUP message is translated by
    /// the TranslateMessage function. WM_DEADCHAR specifies a character code generated by a
    /// dead key. A dead key is a key that generates a character, such as the umlaut (double-dot),
    /// that is combined with another character to form a composite character. For example, the
    /// umlaut-O character ( ) is generated by typing the dead key for the umlaut character,
    /// and then typing the O key.
    /// </summary>
    public const uint WM_DEADCHAR = 0x0103;

    /// <summary>
    /// Posted when the user presses a hot key registered by the RegisterHotKey function.
    /// The message is placed at the top of the message queue associated with the thread
    /// that registered the hot key.
    /// </summary>
    public const uint WM_HOTKEY = 0x0312;

    /// <summary>
    /// Posted to the window with the keyboard focus when a nonsystem key is pressed.
    /// A nonsystem key is a key that is pressed when the ALT key is not pressed.
    /// </summary>
    public const uint WM_KEYDOWN = 0x0100;

    /// <summary>
    /// Posted to the window with the keyboard focus when a nonsystem key is released.
    /// A nonsystem key is a key that is pressed when the ALT key is not pressed, or a
    /// keyboard key that is pressed when a window has the keyboard focus.
    /// </summary>
    public const uint WM_KEYUP = 0x0101;

    /// <summary>
    /// Sent to a window immediately before it loses the keyboard focus.
    /// </summary>
    public const uint WM_KILLFOCUS = 0x0008;

    /// <summary>
    /// Sent to a window after it has gained the keyboard focus.
    /// </summary>
    public const uint WM_SETFOCUS = 0x0007;

    /// <summary>
    /// Sent to the window with the keyboard focus when a WM_SYSKEYDOWN message is translated
    /// by the TranslateMessage function. WM_SYSDEADCHAR specifies the character code of a
    /// system dead key that is, a dead key that is pressed while holding down the ALT key.
    /// </summary>
    public const uint WM_SYSDEADCHAR = 0x0107;

    /// <summary>
    /// Posted to the window with the keyboard focus when the user presses the F10 key (which
    /// activates the menu bar) or holds down the ALT key and then presses another key. It
    /// also occurs when no window currently has the keyboard focus; in this case, the
    /// WM_SYSKEYDOWN message is sent to the active window. The window that receives the
    /// message can distinguish between these two contexts by checking the context code in the
    /// lParam parameter.
    /// </summary>
    public const uint WM_SYSKEYDOWN = 0x104;

    /// <summary>
    /// Posted to the window with the keyboard focus when the user releases a key that was
    /// pressed while the ALT key was held down. It also occurs when no window currently has
    /// the keyboard focus; in this case, the WM_SYSKEYUP message is sent to the active window.
    /// The window that receives the message can distinguish between these two contexts by
    /// checking the context code in the lParam parameter.
    /// </summary>
    public const uint WM_SYSKEYUP = 0x0105;

    /// <summary>
    /// The WM_UNICHAR message can be used by an application to post input to other windows.
    /// This message contains the character code of the key that was pressed. (Test whether
    /// a target app can process WM_UNICHAR messages by sending the message with wParam set
    /// to UNICODE_NOCHAR.)
    /// </summary>
    public const uint WM_UNICHAR = 0x0109;

    #endregion

    #region Mouse Input / Mouse Input Reference / Mouse Input Notifications
    // see https://learn.microsoft.com/en-us/windows/win32/inputdev/mouse-input-notifications

    /// <summary>
    /// Sent to the window that is losing the mouse capture.
    /// </summary>
    public const uint WM_CAPTURECHANGED = 0x0215;

    /// <summary>
    /// Posted when the user double-clicks the left mouse button while the cursor is in the
    /// client area of a window. If the mouse is not captured, the message is posted to the
    /// window beneath the cursor. Otherwise, the message is posted to the window that has
    /// captured the mouse.
    /// </summary>
    public const uint WM_LBUTTONDBLCLK = 0x0203;

    /// <summary>
    /// Posted when the user presses the left mouse button while the cursor is in the client
    /// area of a window. If the mouse is not captured, the message is posted to the window
    /// beneath the cursor. Otherwise, the message is posted to the window that has captured
    /// the mouse.
    /// </summary>
    public const uint WM_LBUTTONDOWN = 0x0201;

    /// <summary>
    /// Posted when the user releases the left mouse button while the cursor is in the client
    /// area of a window. If the mouse is not captured, the message is posted to the window
    /// beneath the cursor. Otherwise, the message is posted to the window that has captured
    /// the mouse.
    /// </summary>
    public const uint WM_LBUTTONUP = 0x0202;

    /// <summary>
    /// Posted when the user double-clicks the middle mouse button while the cursor is in the
    /// client area of a window. If the mouse is not captured, the message is posted to the
    /// window beneath the cursor. Otherwise, the message is posted to the window that has
    /// captured the mouse.
    /// </summary>
    public const uint WM_MBUTTONDBLCLK = 0x0209;

    /// <summary>
    /// Posted when the user presses the middle mouse button while the cursor is in the client
    /// area of a window. If the mouse is not captured, the message is posted to the window
    /// beneath the cursor. Otherwise, the message is posted to the window that has captured
    /// the mouse.
    /// </summary>
    public const uint WM_MBUTTONDOWN = 0x0207;

    /// <summary>
    /// Posted when the user releases the middle mouse button while the cursor is in the client
    /// area of a window. If the mouse is not captured, the message is posted to the window
    /// beneath the cursor. Otherwise, the message is posted to the window that has captured
    /// the mouse.
    /// </summary>
    public const uint WM_MBUTTONUP = 0x0208;

    /// <summary>
    /// Sent when the cursor is in an inactive window and the user presses a mouse button. The
    /// parent window receives this message only if the child window passes it to the
    /// DefWindowProc function.
    /// </summary>
    public const uint WM_MOUSEACTIVATE = 0x0021;

    /// <summary>
    /// Posted to a window when the cursor hovers over the client area of the window for the
    /// period of time specified in a prior call to TrackMouseEvent.
    /// </summary>
    public const uint WM_MOUSEHOVER = 0x02A1;

    /// <summary>
    /// Sent to the active window when the mouse's horizontal scroll wheel is tilted or rotated.
    /// The DefWindowProc function propagates the message to the window's parent. There should
    /// be no internal forwarding of the message, since DefWindowProc propagates it up the
    /// parent chain until it finds a window that processes it.
    /// </summary>
    public const uint WM_MOUSEHWHEEL = 0x020E;

    /// <summary>
    /// Posted to a window when the cursor leaves the client area of the window specified
    /// in a prior call to TrackMouseEvent.
    /// </summary>
    public const uint WM_MOUSELEAVE = 0x02A3;

    /// <summary>
    /// Posted to a window when the cursor moves. If the mouse is not captured, the message is
    /// posted to the window that contains the cursor. Otherwise, the message is posted to the
    /// window that has captured the mouse.
    /// </summary>
    public const uint WM_MOUSEMOVE = 0x0200;

    /// <summary>
    /// Sent to the focus window when the mouse wheel is rotated. The DefWindowProc function
    /// propagates the message to the window's parent. There should be no internal forwarding
    /// of the message, since DefWindowProc propagates it up the parent chain until it finds
    /// a window that processes it.
    /// </summary>
    public const uint WM_MOUSEWHEEL = 0x020A;

    /// <summary>
    /// Sent to a window in order to determine what part of the window corresponds to a particular
    /// screen coordinate. This can happen, for example, when the cursor moves, when a mouse
    /// button is pressed or released, or in response to a call to a function such as WindowFromPoint.
    /// If the mouse is not captured, the message is sent to the window beneath the cursor. Otherwise,
    /// the message is sent to the window that has captured the mouse.
    /// </summary>
    public const uint WM_NCHITTEST = 0x0084;

    /// <summary>
    /// Posted when the user double-clicks the left mouse button while the cursor is within the
    /// nonclient area of a window. This message is posted to the window that contains the cursor.
    /// If a window has captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCLBUTTONDBLCLK = 0x00A3;

    /// <summary>
    /// Posted when the user presses the left mouse button while the cursor is within the nonclient
    /// area of a window. This message is posted to the window that contains the cursor. If a window
    /// has captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCLBUTTONDOWN = 0x00A1;

    /// <summary>
    /// Posted when the user releases the left mouse button while the cursor is within the nonclient
    /// area of a window. This message is posted to the window that contains the cursor. If a window
    /// has captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCLBUTTONUP = 0x00A2;

    /// <summary>
    /// Posted when the user double-clicks the middle mouse button while the cursor is within the
    /// nonclient area of a window. This message is posted to the window that contains the cursor.
    /// If a window has captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCMBUTTONDBLCLK = 0x00A9;

    /// <summary>
    /// Posted when the user presses the middle mouse button while the cursor is within the nonclient
    /// area of a window. This message is posted to the window that contains the cursor. If a window
    /// has captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCMBUTTONDOWN = 0x00A7;

    /// <summary>
    /// Posted when the user releases the middle mouse button while the cursor is within the nonclient
    /// area of a window. This message is posted to the window that contains the cursor. If a window
    /// has captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCMBUTTONUP = 0x00A8;

    /// <summary>
    /// Posted to a window when the cursor hovers over the nonclient area of the window for the period
    /// of time specified in a prior call to TrackMouseEvent.
    /// </summary>
    public const uint WM_NCMOUSEHOVER = 0x02A0;

    /// <summary>
    /// Posted to a window when the cursor leaves the nonclient area of the window specified in a prior
    /// call to TrackMouseEvent.
    /// </summary>
    public const uint WM_NCMOUSELEAVE = 0x2a2;

    /// <summary>
    /// Posted to a window when the cursor is moved within the nonclient area of the window. This message
    /// is posted to the window that contains the cursor. If a window has captured the mouse, this message
    /// is not posted.
    /// </summary>
    public const uint WM_NCMOUSEMOVE = 0x00a0;

    /// <summary>
    /// Posted when the user double-clicks the right mouse button while the cursor is within the nonclient
    /// area of a window. This message is posted to the window that contains the cursor. If a window has
    /// captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCRBUTTONDBLCLK = 0x00A6;

    /// <summary>
    /// Posted when the user presses the right mouse button while the cursor is within the nonclient area
    /// of a window. This message is posted to the window that contains the cursor. If a window has
    /// captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCRBUTTONDOWN = 0x00A4;

    /// <summary>
    /// Posted when the user releases the right mouse button while the cursor is within the nonclient
    /// area of a window. This message is posted to the window that contains the cursor. If a window
    /// has captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCRBUTTONUP = 0x00A5;

    /// <summary>
    /// Posted when the user double-clicks the first or second X button while the cursor is in the
    /// nonclient area of a window. This message is posted to the window that contains the cursor.
    /// If a window has captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCXBUTTONDBLCLK = 0x00AD;

    /// <summary>
    /// Posted when the user presses the first or second X button while the cursor is in the nonclient
    /// area of a window. This message is posted to the window that contains the cursor. If a window
    /// has captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCXBUTTONDOWN = 0x00AB;

    /// <summary>
    /// Posted when the user releases the first or second X button while the cursor is in the nonclient
    /// area of a window. This message is posted to the window that contains the cursor. If a window
    /// has captured the mouse, this message is not posted.
    /// </summary>
    public const uint WM_NCXBUTTONUP = 0x00AC;

    /// <summary>
    /// Posted when the user double-clicks the right mouse button while the cursor is in the client
    /// area of a window. If the mouse is not captured, the message is posted to the window beneath
    /// the cursor. Otherwise, the message is posted to the window that has captured the mouse.
    /// </summary>
    public const uint WM_RBUTTONDBLCLK = 0x0206;

    /// <summary>
    /// Posted when the user presses the right mouse button while the cursor is in the client area
    /// of a window. If the mouse is not captured, the message is posted to the window beneath the
    /// cursor. Otherwise, the message is posted to the window that has captured the mouse.
    /// </summary>
    public const uint WM_RBUTTONDOWN = 0x0204;

    /// <summary>
    /// Posted when the user releases the right mouse button while the cursor is in the client
    /// area of a window. If the mouse is not captured, the message is posted to the window beneath
    /// the cursor. Otherwise, the message is posted to the window that has captured the mouse.
    /// </summary>
    public const uint WM_RBUTTONUP = 0x0205;

    /// <summary>
    /// Posted when the user double-clicks the first or second X button while the cursor is in the
    /// client area of a window. If the mouse is not captured, the message is posted to the window
    /// beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
    /// </summary>
    public const uint WM_XBUTTONDBLCLK = 0x020D;

    /// <summary>
    /// Posted when the user presses the first or second X button while the cursor is in the client
    /// area of a window. If the mouse is not captured, the message is posted to the window beneath
    /// the cursor. Otherwise, the message is posted to the window that has captured the mouse.
    /// </summary>
    public const uint WM_XBUTTONDOWN = 0x020B;

    /// <summary>
    /// Posted when the user releases the first or second X button while the cursor is in the client
    /// area of a window. If the mouse is not captured, the message is posted to the window beneath
    /// the cursor. Otherwise, the message is posted to the window that has captured the mouse.
    /// </summary>
    public const uint WM_XBUTTONUP = 0x020C;

    #endregion

    #endregion

    #region Learn / Windows / Apps / Win32 / Desktop Technologies / Desktop App User Interface / Internationalization
    // see https://learn.microsoft.com/en-us/windows/win32/intl/international-support

    #region Input Method Manager / Input Method Manager Reference / Input Method Manager Messages
    // see https://learn.microsoft.com/en-us/windows/win32/intl/input-method-manager-messages

    /// <summary>
    /// Sent to an application to notify it of changes to the IME window.
    /// </summary>
    public const uint WM_IME_NOTIFY = 0x0282;

    /// <summary>
    /// Sent to an application when a window is activated.
    /// </summary>
    public const uint WM_IME_SETCONTEXT = 0x281;

    #endregion

    #endregion

    #region Learn / Windows / Apps / Win32 / Desktop Technologies / Desktop App User Interface / Menus and Other Resources
    // see https://learn.microsoft.com/en-us/windows/win32/menurc/resources

    #region Cursors / Cursor Reference / Cursor Notifications
    // see https://learn.microsoft.com/en-us/windows/win32/menurc/cursor-notifications

    /// <summary>
    /// Sent to a window if the mouse causes the cursor to move within
    /// a window and mouse input is not captured.
    /// </summary>
    public const uint WM_SETCURSOR = 0x0020;

    #endregion

    #region Keyboard Accelerators / Keyboard Accelerator Reference / Keyboard Accelerator Notifications
    // see https://learn.microsoft.com/en-us/windows/win32/menurc/keyboard-accelerator-notifications

    /// <summary>
    /// Sent when a drop-down menu or submenu is about to become active.
    /// This allows an application to modify the menu before it is displayed, without changing the entire menu.
    /// </summary>
    public const uint WM_INITMENUPOPUP = 0x0117;

    /// <summary>
    /// Sent when a menu is active and the user presses a key that does not correspond to any
    /// mnemonic or accelerator key. This message is sent to the window that owns the menu.
    /// </summary>
    public const uint WM_MENUCHAR = 0x0120;

    /// <summary>
    /// Sent to a menu's owner window when the user selects a menu item.
    /// </summary>
    public const uint WM_MENUSELECT = 0x011F;

    /// <summary>
    /// Posted to the window with the keyboard focus when a WM_SYSKEYDOWN message is translated by
    /// the TranslateMessage function. It specifies the character code of a system character key
    /// that is, a character key that is pressed while the ALT key is down.
    /// </summary>
    public const uint WM_SYSCHAR = 0x0106;

    /// <summary>
    /// A window receives this message when the user chooses a command from the Window menu
    /// (formerly known as the system or control menu) or when the user chooses the maximize
    /// button, minimize button, restore button, or close button.
    /// </summary>
    public const uint WM_SYSCOMMAND = 0x0112;

    #endregion

    #endregion

    #region Learn / Windows / Apps / Win32 / Desktop Technologies / Desktop App User Interface / Windows and Messages
    // see https://learn.microsoft.com/en-us/windows/win32/winmsg/windowing

    #region Windows / Window Reference / Window Constants / Window Styles
    // see https://learn.microsoft.com/en-us/windows/win32/winmsg/window-styles

    /// <summary>
    /// The window has a thin-line border
    /// </summary>
    public const uint WS_BORDER = 0x00800000;

    /// <summary>
    /// The window has a title bar (includes the WS_BORDER style).
    /// </summary>
    public const uint WS_CAPTION = 0x00C00000;

    /// <summary>
    /// The window is a child window.
    /// A window with this style cannot have a menu bar.
    /// This style cannot be used with the WS_POPUP style.
    /// </summary>
    public const uint WS_CHILD = 0x40000000;

    /// <summary>
    /// Same as the WS_CHILD style.
    /// </summary>
    public const uint WS_CHILDWINDOW = 0x40000000;

    /// <summary>
    /// Excludes the area occupied by child windows when drawing occurs within the
    /// parent window. This style is used when creating the parent window.
    /// </summary>
    public const uint WS_CLIPCHILDREN = 0x02000000;

    /// <summary>
    /// Clips child windows relative to each other; that is, when a particular child
    /// window receives a WM_PAINT message, the WS_CLIPSIBLINGS style clips all other
    /// overlapping child windows out of the region of the child window to be updated.
    /// If WS_CLIPSIBLINGS is not specified and child windows overlap, it is possible,
    /// when drawing within the client area of a child window, to draw within the
    /// client area of a neighboring child window.
    /// </summary>
    public const uint WS_CLIPSIBLINGS = 0x04000000;

    /// <summary>
    /// The window is initially disabled.
    /// A disabled window cannot receive input from the user.
    /// To change this after a window has been created, use the EnableWindow function.
    /// </summary>
    public const uint WS_DISABLED = 0x08000000;

    /// <summary>
    /// The window has a border of a style typically used with dialog boxes.
    /// A window with this style cannot have a title bar.
    /// </summary>
    public const uint WS_DLGFRAME = 0x00400000;

    /// <summary>
    /// The window is the first control of a group of controls. The group consists of this
    /// first control and all controls defined after it, up to the next control with the
    /// WS_GROUP style. The first control in each group usually has the WS_TABSTOP style
    /// so that the user can move from group to group. The user can subsequently change the
    /// keyboard focus from one control in the group to the next control in the group by
    /// using the direction keys.
    ///
    /// You can turn this style on and off to change dialog box navigation. To change this
    /// style after a window has been created, use the SetWindowLong function.
    /// </summary>
    public const uint WS_GROUP = 0x00020000;

    /// <summary>
    /// The window has a horizontal scroll bar.
    /// </summary>
    public const uint WS_HSCROLL = 0x00100000;

    /// <summary>
    /// The window is initially minimized.
    /// Same as the WS_MINIMIZE style.
    /// </summary>
    public const uint WS_ICONIC = 0x20000000;

    /// <summary>
    /// The window is initially maximized.
    /// </summary>
    public const uint WS_MAXIMIZE = 0x01000000;

    /// <summary>
    /// The window has a maximize button.
    /// Cannot be combined with the WS_EX_CONTEXTHELP style.
    /// The WS_SYSMENU style must also be specified.
    /// </summary>
    public const uint WS_MAXIMIZEBOX = 0x00010000;

    /// <summary>
    /// The window is initially minimized.
    /// Same as the WS_ICONIC style.
    /// </summary>
    public const uint WS_MINIMIZE = 0x20000000;

    /// <summary>
    /// The window has a minimize button.
    /// Cannot be combined with the WS_EX_CONTEXTHELP style.
    /// The WS_SYSMENU style must also be specified.
    /// </summary>
    public const uint WS_MINIMIZEBOX = 0x00020000;

    /// <summary>
    /// The window is an overlapped window.
    /// An overlapped window has a title bar and a border.
    /// Same as the WS_TILED style.
    /// </summary>
    public const uint WS_OVERLAPPED = 0x00000000;

    /// <summary>
    /// The window is an overlapped window.
    /// Same as the WS_TILEDWINDOW style.
    /// </summary>
    public const uint WS_OVERLAPPEDWINDOW =
        Winuser.WS_OVERLAPPED |
        Winuser.WS_CAPTION |
        Winuser.WS_SYSMENU |
        Winuser.WS_THICKFRAME |
        Winuser.WS_MINIMIZEBOX |
        Winuser.WS_MAXIMIZEBOX;

    /// <summary>
    /// The window is a pop-up window.
    /// This style cannot be used with the WS_CHILD style.
    /// </summary>
    public const uint WS_POPUP = 0x80000000;

    /// <summary>
    /// The window is a pop-up window.
    /// The WS_CAPTION and WS_POPUPWINDOW styles must be combined
    /// to make the window menu visible.
    /// </summary>
    public const uint WS_POPUPWINDOW =
        Winuser.WS_POPUP |
        Winuser.WS_BORDER |
        Winuser.WS_SYSMENU;

    /// <summary>
    /// The window has a sizing border.
    /// Same as the WS_THICKFRAME style.
    /// </summary>
    public const uint WS_SIZEBOX = 0x00040000;

    /// <summary>
    /// The window has a window menu on its title bar.
    /// The WS_CAPTION style must also be specified.
    /// </summary>
    public const uint WS_SYSMENU = 0x00080000;

    /// <summary>
    /// The window is a control that can receive the keyboard focus when the user
    /// presses the TAB key. Pressing the TAB key changes the keyboard focus to the
    /// next control with the WS_TABSTOP style.
    ///
    /// You can turn this style on and off to change dialog box navigation. To change
    /// this style after a window has been created, use the SetWindowLong function.
    /// For user-created windows and modeless dialogs to work with tab stops, alter
    /// the message loop to call the IsDialogMessage function.
    /// </summary>
    public const uint WS_TABSTOP = 0x00010000;

    /// <summary>
    /// The window has a sizing border.
    /// Same as the WS_SIZEBOX style.
    /// </summary>
    public const uint WS_THICKFRAME = 0x00040000;

    /// <summary>
    /// The window is an overlapped window.
    /// An overlapped window has a title bar and a border.
    /// Same as the WS_OVERLAPPED style.
    /// </summary>
    public const uint WS_TILED = 0x00000000;

    /// <summary>
    /// The window is an overlapped window.
    /// Same as the WS_OVERLAPPEDWINDOW style.
    /// </summary>
    public const uint WS_TILEDWINDOW =
        Winuser.WS_OVERLAPPED |
        Winuser.WS_CAPTION |
        Winuser.WS_SYSMENU |
        Winuser.WS_THICKFRAME |
        Winuser.WS_MINIMIZEBOX |
        Winuser.WS_MAXIMIZEBOX;

    /// <summary>
    /// The window is initially visible.
    /// This style can be turned on and off by using the ShowWindow or SetWindowPos function.
    /// </summary>
    public const uint WS_VISIBLE = 0x10000000;

    /// <summary>
    /// The window has a vertical scroll bar.
    /// </summary>
    public const uint WS_VSCROLL = 0x00200000;

    #endregion

    #region Windows / Window Reference / Window Functions
    // see https://learn.microsoft.com/en-us/windows/win32/winmsg/window-functions

    /// <summary>
    /// Creates an overlapped, pop-up, or child window with an extended window style
    /// </summary>
    /// <param name="dwExStyle">
    /// The extended window style of the window being created.
    /// </param>
    /// <param name="lpClassName">
    /// A null-terminated string or a class atom created by a previous call to the RegisterClass
    /// or RegisterClassEx function. The atom must be in the low-order word of lpClassName; the
    /// high-order word must be zero. If lpClassName is a string, it specifies the window class
    /// name. The class name can be any name registered with RegisterClass or RegisterClassEx,
    /// provided that the module that registers the class is also the module that creates the
    /// window. The class name can also be any of the predefined system class names.
    /// </param>
    /// <param name="lpWindowName">
    /// The window name. If the window style specifies a title bar, the window title pointed to by
    /// lpWindowName is displayed in the title bar. When using CreateWindow to create controls,
    /// such as buttons, check boxes, and static controls, use lpWindowName to specify the text of
    /// the control. When creating a static control with the SS_ICON style, use lpWindowName to
    /// specify the icon name or identifier. To specify an identifier, use the syntax "#num".
    /// </param>
    /// <param name="dwStyle">
    /// The style of the window being created. This parameter can be a combination of the window
    /// style values, plus the control styles indicated in the Remarks section.
    /// </param>
    /// <param name="x">
    /// The initial horizontal position of the window. For an overlapped or pop-up window, the x
    /// parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates.
    /// For a child window, x is the x-coordinate of the upper-left corner of the window relative to
    /// the upper-left corner of the parent window's client area. If x is set to CW_USEDEFAULT, the
    /// system selects the default position for the window's upper-left corner and ignores the y
    /// parameter. CW_USEDEFAULT is valid only for overlapped windows; if it is specified for a pop-up
    /// or child window, the x and y parameters are set to zero.
    /// </param>
    /// <param name="y">
    /// The initial vertical position of the window. For an overlapped or pop-up window, the y
    /// parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates.
    /// For a child window, y is the initial y-coordinate of the upper-left corner of the child window
    /// relative to the upper-left corner of the parent window's client area. For a list box y is the
    /// initial y-coordinate of the upper-left corner of the list box's client area relative to the
    /// upper-left corner of the parent window's client area.
    ///
    /// If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter is
    /// set to CW_USEDEFAULT, then the y parameter determines how the window is shown.If the y
    /// parameter is CW_USEDEFAULT, then the window manager calls ShowWindow with the SW_SHOW flag
    /// after the window has been created.If the y parameter is some other value, then the window
    /// manager calls ShowWindow with that value as the nCmdShow parameter.
    /// </param>
    /// <param name="nWidth">
    /// The width, in device units, of the window. For overlapped windows, nWidth is the window's
    /// width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT, the system
    /// selects a default width and height for the window; the default width extends from the
    /// initial x-coordinates to the right edge of the screen; the default height extends from
    /// the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid only for
    /// overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window, the
    /// nWidth and nHeight parameter are set to zero.
    /// </param>
    /// <param name="nHeight">
    /// The height, in device units, of the window. For overlapped windows, nHeight is the window's
    /// height, in screen coordinates. If the nWidth parameter is set to CW_USEDEFAULT, the system
    /// ignores nHeight.
    /// </param>
    /// <param name="hWndParent">
    /// A handle to the parent or owner window of the window being created. To create a child
    /// window or an owned window, supply a valid window handle. This parameter is optional
    /// for pop-up windows.
    ///
    /// To create a message-only window, supply HWND_MESSAGE or a handle to an existing
    /// message-only window.
    /// </param>
    /// <param name="hMenu">
    /// A handle to a menu, or specifies a child-window identifier, depending on the window
    /// style. For an overlapped or pop-up window, hMenu identifies the menu to be used with
    /// the window; it can be NULL if the class menu is to be used. For a child window, hMenu
    /// specifies the child-window identifier, an integer value used by a dialog box control
    /// to notify its parent about events. The application determines the child-window
    /// identifier; it must be unique for all child windows with the same parent window.
    /// </param>
    /// <param name="hInstance">
    /// A handle to the instance of the module to be associated with the window.
    /// </param>
    /// <param name="lpParam">
    /// Pointer to a value to be passed to the window through the CREATESTRUCT structure
    /// (lpCreateParams member) pointed to by the lParam param of the WM_CREATE message.
    /// This message is sent to the created window by this function before it returns.
    ///
    /// If an application calls CreateWindow to create a MDI client window, lpParam should
    /// point to a CLIENTCREATESTRUCT structure.If an MDI client window calls CreateWindow
    /// to create an MDI child window, lpParam should point to a MDICREATESTRUCT structure.
    /// lpParam may be NULL if no additional data is needed.
    /// </param>
    /// <returns>
    /// If the function succeeds, the return value is a handle to the new window.
    /// If the function fails, the return value is NULL.To get extended error information, call GetLastError.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw
    /// </remarks>
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    public static extern IntPtr CreateWindowEx(
    int dwExStyle,
    //[MarshalAs(UnmanagedType.LPStr)]
    //string lpClassName,
        ushort lpClassName,
        [MarshalAs(UnmanagedType.LPStr)]
        string lpWindowName,
        uint dwStyle,
        int x,
        int y,
        int nWidth,
        int nHeight,
        IntPtr hWndParent,
        IntPtr hMenu,
        IntPtr hInstance,
        IntPtr lpParam
    );

    #region ShowWindow

    /// <summary>
    /// Sets the specified window's show state.
    /// </summary>
    /// <param name="hWnd">A handle to the window.</param>
    /// <param name="nCmdShow">Controls how the window is to be shown. </param>
    /// <returns>
    /// If the window was previously visible, the return value is nonzero.
    /// If the window was previously hidden, the return value is zero.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow
    /// </remarks>
    [DllImport("user32.dll")]
    public static extern uint ShowWindow(
        IntPtr hWnd,
        int nCmdShow
    );

    /// <summary>
    /// Hides the window and activates another window.
    /// </summary>
    public const int SW_HIDE = 0;

    /// <summary>
    /// Activates and displays a window.
    /// If the window is minimized or maximized, the system restores it to its original size and position.
    /// An application should specify this flag when displaying the window for the first time.
    /// </summary>
    public const int SW_SHOWNORMAL = 1;

    /// <summary>
    /// Activates and displays a window.
    /// If the window is minimized or maximized, the system restores it to its original size and position.
    /// An application should specify this flag when displaying the window for the first time.
    /// </summary>
    public const int SW_NORMAL = 1;

    /// <summary>
    /// Activates the window and displays it as a minimized window.
    /// </summary>
    public const int SW_SHOWMINIMIZED = 2;

    /// <summary>
    /// Activates the window and displays it as a maximized window.
    /// </summary>
    public const int SW_SHOWMAXIMIZED = 3;

    /// <summary>
    /// Activates the window and displays it as a maximized window.
    /// </summary>
    public const int SW_MAXIMIZE = 3;

    /// <summary>
    /// Displays a window in its most recent size and position.
    /// This value is similar to SW_SHOWNORMAL, except that the window is not activated.
    /// </summary>
    public const int SW_SHOWNOACTIVATE = 4;

    /// <summary>
    /// Activates the window and displays it in its current size and position.
    /// </summary>
    public const int SW_SHOW = 5;

    /// <summary>
    /// Minimizes the specified window and activates the next top-level window in the Z order.
    /// </summary>
    public const int SW_MINIMIZE = 6;

    /// <summary>
    /// Displays the window as a minimized window.
    /// This value is similar to SW_SHOWMINIMIZED, except the window is not activated.
    /// </summary>
    public const int SW_SHOWMINNOACTIVE = 7;

    /// <summary>
    /// Displays the window in its current size and position.
    /// This value is similar to SW_SHOW, except that the window is not activated.
    /// </summary>
    public const int SW_SHOWNA = 8;

    /// <summary>
    /// Activates and displays the window.
    /// If the window is minimized or maximized, the system restores it to its original size and position.
    /// An application should specify this flag when restoring a minimized window.
    /// </summary>
    public const int SW_RESTORE = 9;

    /// <summary>
    /// Sets the show state based on the SW_ value specified in the STARTUPINFO structure passed to
    /// the CreateProcess function by the program that started the application.
    /// </summary>
    public const int SW_SHOWDEFAULT = 10;

    /// <summary>
    /// Minimizes a window, even if the thread that owns the window is not responding.
    /// This flag should only be used when minimizing windows from a different thread.
    /// </summary>
    public const int SW_FORCEMINIMIZE = 11;

    #endregion

    #endregion

    #region Windows / Window Reference / Window Messages
    // see https://learn.microsoft.com/en-us/windows/win32/winmsg/window-messages

    /// <summary>
    /// Retrieves the menu handle for the current window.
    /// </summary>
    public const uint MN_GETHMENU = 0x01E1;

    /// <summary>
    /// Sent when the window background must be erased (for example, when a window is resized).
    /// The message is sent to prepare an invalidated portion of a window for painting.
    /// </summary>
    public const uint WM_ERASEBKGND = 0x0014;

    /// <summary>
    /// Retrieves the font with which the control is currently drawing its text.
    /// </summary>
    public const uint WM_GETFONT = 0x0031;

    /// <summary>
    /// Copies the text that corresponds to a window into a buffer provided by the caller.
    /// </summary>
    public const uint WM_GETTEXT = 0x000D;

    /// <summary>
    /// Determines the length, in characters, of the text associated with a window.
    /// </summary>
    public const uint WM_GETTEXTLENGTH = 0x000E;

    /// <summary>
    /// Sets the font that a control is to use when drawing text.
    /// </summary>
    public const uint WM_SETFONT = 0x0030;

    /// <summary>
    /// Associates a new large or small icon with a window.
    /// The system displays the large icon in the ALT+TAB dialog box,
    /// and the small icon in the window caption.
    /// </summary>
    public const uint WM_SETICON = 0x0080;

    /// <summary>
    /// Sets the text of a window.
    /// </summary>
    public const uint WM_SETTEXT = 0x000C;

    #endregion

    #region Windows / Window Reference / Window Notifications
    // see https://learn.microsoft.com/en-us/windows/win32/winmsg/window-notifications

    /// <summary>
    /// Sent when a window belonging to a different application than the active window is
    /// about to be activated. The message is sent to the application whose window is being
    /// activated and to the application whose window is being deactivated.
    /// </summary>
    public const uint WM_ACTIVATEAPP = 0x001C;

    /// <summary>
    /// Sent to cancel certain modes, such as mouse capture. For example, the system sends this
    /// message to the active window when a dialog box or message box is displayed. Certain functions
    /// also send this message explicitly to the specified window regardless of whether it is the
    /// active window. For example, the EnableWindow function sends this message when disabling the
    /// specified window.
    /// </summary>
    public const uint WM_CANCELMODE = 0x001F;

    /// <summary>
    /// Sent to a child window when the user clicks the window's title bar or when the window
    /// is activated, moved, or sized.
    /// </summary>
    public const uint WM_CHILDACTIVATE = 0x0022;

    /// <summary>
    /// Sent as a signal that a window or an application should terminate.
    /// </summary>
    public const uint WM_CLOSE = 0x0010;

    /// <summary>
    /// Sent to all top-level windows when the system detects more than 12.5 percent of system
    /// time over a 30- to 60-second interval is being spent compacting memory. This indicates
    /// that system memory is low.
    /// </summary>
    public const uint WM_COMPACTING = 0x0041;

    /// <summary>
    /// Sent when an application requests that a window be created by calling the CreateWindowEx
    /// or CreateWindow function. (The message is sent before the function returns.) The window
    /// procedure of the new window receives this message after the window is created, but before
    /// the window becomes visible.
    /// </summary>
    public const uint WM_CREATE = 0x0001;

    /// <summary>
    /// Sent when a window is being destroyed. It is sent to the window procedure of the window
    /// being destroyed after the window is removed from the screen.
    ///
    /// This message is sent first to the window being destroyed and then to the child windows
    /// (if any) as they are destroyed.During the processing of the message, it can be assumed
    /// that all child windows still exist.
    /// </summary>
    public const uint WM_DESTROY = 0x0002;

    /// <summary>
    /// Sent when an application changes the enabled state of a window. It is sent to the window
    /// whose enabled state is changing. This message is sent before the EnableWindow function
    /// returns, but after the enabled state (WS_DISABLED style bit) of the window has changed.
    /// </summary>
    public const uint WM_ENABLE = 0x000A;

    /// <summary>
    /// Sent one time to a window after it enters the moving or sizing modal loop. The window
    /// enters the moving or sizing modal loop when the user clicks the window's title bar or
    /// sizing border, or when the window passes the WM_SYSCOMMAND message to the DefWindowProc
    /// function and the wParam parameter of the message specifies the SC_MOVE or SC_SIZE value.
    /// The operation is complete when DefWindowProc returns.
    ///
    /// The system sends the WM_ENTERSIZEMOVE message regardless of whether the dragging of
    /// full windows is enabled.
    /// </summary>
    public const uint WM_ENTERSIZEMOVE = 0x0231;

    /// <summary>
    /// Sent one time to a window, after it has exited the moving or sizing modal loop. The
    /// window enters the moving or sizing modal loop when the user clicks the window's title
    /// bar or sizing border, or when the window passes the WM_SYSCOMMAND message to the
    /// DefWindowProc function and the wParam parameter of the message specifies the SC_MOVE
    /// or SC_SIZE value. The operation is complete when DefWindowProc returns.
    /// </summary>
    public const uint WM_EXITSIZEMOVE = 0x0232;

    /// <summary>
    /// Sent to a window to retrieve a handle to the large or small icon associated with a
    /// window. The system displays the large icon in the ALT+TAB dialog, and the small
    /// icon in the window caption.
    /// </summary>
    public const uint WM_GETICON = 0x007F;

    /// <summary>
    /// Sent to a window when the size or position of the window is about to change. An
    /// application can use this message to override the window's default maximized size
    /// and position, or its default minimum or maximum tracking size.
    /// </summary>
    public const uint WM_GETMINMAXINFO = 0x0024;

    /// <summary>
    /// Sent to the topmost affected window after an application's input language has been
    /// changed. You should make any application-specific settings and pass the message to
    /// the DefWindowProc function, which passes the message to all first-level child windows.
    /// These child windows can pass the message to DefWindowProc to have it pass the message
    /// to their child windows, and so on.
    /// </summary>
    public const uint WM_INPUTLANGCHANGE = 0x0051;

    /// <summary>
    /// Posted to the window with the focus when the user chooses a new input language, either
    /// with the hotkey (specified in the Keyboard control panel application) or from the
    /// indicator on the system taskbar. An application can accept the change by passing the
    /// message to the DefWindowProc function or reject the change (and prevent it from taking
    /// place) by returning immediately.
    /// </summary>
    public const uint WM_INPUTLANGCHANGEREQUEST = 0x0050;

    /// <summary>
    /// Sent after a window has been moved.
    /// </summary>
    public const uint WM_MOVE = 0x0003;

    /// <summary>
    /// Sent to a window that the user is moving. By processing this message, an application
    /// can monitor the position of the drag rectangle and, if needed, change its position.
    /// </summary>
    public const uint WM_MOVING = 0x0216;

    /// <summary>
    /// Sent to a window when its nonclient area needs to be changed to indicate an active
    /// or inactive state.
    /// </summary>
    public const uint WM_NCACTIVATE = 0x0086;

    /// <summary>
    /// Sent when the size and position of a window's client area must be calculated. By
    /// processing this message, an application can control the content of the window's
    /// client area when the size or position of the window changes.
    /// </summary>
    public const uint WM_NCCALCSIZE = 0x0083;

    /// <summary>
    /// Sent prior to the WM_CREATE message when a window is first created.
    /// </summary>
    public const uint WM_NCCREATE = 0x0081;

    /// <summary>
    /// Notifies a window that its nonclient area is being destroyed. The DestroyWindow
    /// function sends the WM_NCDESTROY message to the window following the WM_DESTROY
    /// message.WM_DESTROY is used to free the allocated memory object associated with
    /// the window.
    ///
    /// The WM_NCDESTROY message is sent after the child windows have been destroyed.
    /// In contrast, WM_DESTROY is sent before the child windows are destroyed.
    /// </summary>
    public const uint WM_NCDESTROY = 0x0082;

    /// <summary>
    /// Performs no operation. An application sends the WM_NULL message if it wants to
    /// post a message that the recipient window will ignore.
    /// </summary>
    public const uint WM_NULL = 0x0000;

    /// <summary>
    /// Sent to a minimized (iconic) window. The window is about to be dragged by the
    /// user but does not have an icon defined for its class. An application can return
    /// a handle to an icon or cursor. The system displays this cursor or icon while
    /// the user drags the icon.
    /// </summary>
    public const uint WM_QUERYDRAGICON = 0x0037;

    /// <summary>
    /// Sent to an icon when the user requests that the window be restored to its
    /// previous size and position.
    /// </summary>
    public const uint WM_QUERYOPEN = 0x0013;

    /// <summary>
    /// Indicates a request to terminate an application, and is generated when the
    /// application calls the PostQuitMessage function. This message causes the
    /// GetMessage function to return zero.
    /// </summary>
    public const uint WM_QUIT = 0x0012;

    /// <summary>
    /// Sent to a window when the window is about to be hidden or shown.
    /// </summary>
    public const uint WM_SHOWWINDOW = 0x0018;

    /// <summary>
    /// Sent to a window after its size has changed.
    /// </summary>
    public const uint WM_SIZE = 0x0005;

    /// <summary>
    /// Sent to a window that the user is resizing. By processing this message, an
    /// application can monitor the size and position of the drag rectangle and, if
    /// needed, change its size or position.
    /// </summary>
    public const uint WM_SIZING = 0x0214;

    /// <summary>
    /// Sent to a window after the SetWindowLong function has changed one or more
    /// of the window's styles.
    /// </summary>
    public const uint WM_STYLECHANGED = 0x007D;

    /// <summary>
    /// Sent to a window when the SetWindowLong function is about to change one or
    /// more of the window's styles.
    /// </summary>
    public const uint WM_STYLECHANGING = 0x007C;

    /// <summary>
    /// Broadcast to every window following a theme change event. Examples of theme
    /// change events are the activation of a theme, the deactivation of a theme, or
    /// a transition from one theme to another.
    /// </summary>
    public const uint WM_THEMECHANGED = 0x031A;

    /// <summary>
    /// Sent to all windows after the user has logged on or off. When the user logs on
    /// or off, the system updates the user-specific settings. The system sends this
    /// message immediately after updating the settings.
    /// </summary>
    public const uint WM_USERCHANGED = 0x0054;

    /// <summary>
    /// Sent to a window whose size, position, or place in the Z order has changed as a
    /// result of a call to the SetWindowPos function or another window-management function.
    /// </summary>
    public const uint WM_WINDOWPOSCHANGED = 0x0047;

    /// <summary>
    /// Sent to a window whose size, position, or place in the Z order is about to change
    /// as a result of a call to the SetWindowPos function or another window-management function.
    /// </summary>
    public const uint WM_WINDOWPOSCHANGING = 0x0046;

    #endregion

    #region Window Classes / Window Class Reference / Window Class Functions
    // see https://learn.microsoft.com/en-us/windows/win32/winmsg/window-class-functions

    /// <summary>
    /// Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function.
    /// </summary>
    /// <param name="lpwcx">
    /// A pointer to a WNDCLASSEX structure.
    /// You must fill the structure with the appropriate class attributes before passing it to the function.
    /// </param>
    /// <returns>
    /// If the function succeeds, the return value is a class atom that uniquely identifies the class being registered.
    /// This atom can only be used by the CreateWindow, CreateWindowEx, GetClassInfo, GetClassInfoEx, FindWindow,
    /// FindWindowEx, and UnregisterClass functions and the IActiveIMMap::FilterClientWindows method.
    /// If the function fails, the return value is zero.
    /// To get extended error information, call GetLastError.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassexa
    /// </remarks>
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.U2)]
    public static extern ushort RegisterClassEx(
        [In] ref WNDCLASSEX lpwcx
    );

    #endregion

    #region Window Classes / Window Class Reference / Window Class Structures
    // see https://learn.microsoft.com/en-us/windows/win32/winmsg/window-class-structures

    /// <summary>
    /// Contains window class information. It is used with the RegisterClassEx and GetClassInfoEx  functions.
    /// </summary>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassexw
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct WNDCLASSEX
    {
        [MarshalAs(UnmanagedType.U4)]
        public int cbSize;
        [MarshalAs(UnmanagedType.U4)]
        public int style;
        public IntPtr lpfnWndProc;
        public int cbClsExtra;
        public int cbWndExtra;
        public IntPtr hInstance;
        public IntPtr hIcon;
        public IntPtr hCursor;
        public IntPtr hbrBackground;
        [MarshalAs(UnmanagedType.LPStr)]
        public string lpszMenuName;
        [MarshalAs(UnmanagedType.LPStr)]
        public string lpszClassName;
        public IntPtr hIconSm;
    }

    #endregion

    #region Window Classes / Window Class Reference / Window Class Styles
    // see https://learn.microsoft.com/en-us/windows/win32/winmsg/window-class-styles

    /// <summary>
    /// Aligns the window's client area on a byte boundary (in the x direction).
    /// This style affects the width of the window and its horizontal placement on the display.
    /// </summary>
    public const uint CS_BYTEALIGNCLIENT = 0x1000;

    /// <summary>
    /// Aligns the window on a byte boundary (in the x direction).
    /// This style affects the width of the window and its horizontal placement on the display.
    /// </summary>
    public const uint CS_BYTEALIGNWINDOW = 0x2000;

    /// <summary>
    /// Allocates one device context to be shared by all windows in the class.
    /// Because window classes are process specific, it is possible for multiple threads of an
    /// application to create a window of the same class. It is also possible for the threads
    /// to attempt to use the device context simultaneously. When this happens, the system
    /// allows only one thread to successfully finish its drawing operation.
    /// </summary>
    public const uint CS_CLASSDC = 0x0040;

    /// <summary>
    /// Sends a double-click message to the window procedure when the user double-clicks
    /// the mouse while the cursor is within a window belonging to the class.
    /// </summary>
    public const uint CS_DBLCLKS = 0x0008;

    /// <summary>
    /// Enables the drop shadow effect on a window. The effect is turned on and off through
    /// SPI_SETDROPSHADOW. Typically, this is enabled for small, short-lived windows such
    /// as menus to emphasize their Z-order relationship to other windows. Windows created
    /// from a class with this style must be top-level windows; they may not be child windows.
    /// </summary>
    public const uint CS_DROPSHADOW = 0x00020000;

    /// <summary>
    /// Indicates that the window class is an application global class. For more information,
    /// see the "Application Global Classes" section of About Window Classes.
    /// </summary>
    public const uint CS_GLOBALCLASS = 0x4000;

    /// <summary>
    /// Redraws the entire window if a movement or size adjustment changes the width of
    /// the client area.
    /// </summary>
    public const uint CS_HREDRAW = 0x0002;

    /// <summary>
    /// Disables Close on the window menu.
    /// </summary>
    public const uint CS_NOCLOSE = 0x0200;

    /// <summary>
    /// Allocates a unique device context for each window in the class.
    /// </summary>
    public const uint CS_OWNDC = 0x0020;

    /// <summary>
    /// Sets the clipping rectangle of the child window to that of the parent window so that
    /// the child can draw on the parent. A window with the CS_PARENTDC style bit receives a
    /// regular device context from the system's cache of device contexts. It does not give
    /// the child the parent's device context or device context settings. Specifying
    /// CS_PARENTDC enhances an application's performance.
    /// </summary>
    public const uint CS_PARENTDC = 0x0080;

    /// <summary>
    /// Saves, as a bitmap, the portion of the screen image obscured by a window of this class.
    /// When the window is removed, the system uses the saved bitmap to restore the screen image,
    /// including other windows that were obscured. Therefore, the system does not send WM_PAINT
    /// messages to windows that were obscured if the memory used by the bitmap has not been
    /// discarded and if other screen actions have not invalidated the stored image.
    /// This style is useful for small windows (for example, menus or dialog boxes) that are
    /// displayed briefly and then removed before other screen activity takes place. This style
    /// increases the time required to display the window, because the system must first allocate
    /// memory to store the bitmap.
    /// </summary>
    public const uint CS_SAVEBITS = 0x0800;

    /// <summary>
    /// Redraws the entire window if a movement or size adjustment changes the height of
    /// the client area.
    /// </summary>
    public const uint CS_VREDRAW = 0x0001;

    #endregion

    #region Window Procedures / Window Procedure Reference / Window Procedure Functions
    // see https://learn.microsoft.com/en-us/windows/win32/winmsg/window-procedure-functions

    /// <summary>
    /// Calls the default window procedure to provide default processing for any window messages that an application does not process. 
    /// </summary>
    /// <param name="hWnd">A handle to the window procedure that received the message.</param>
    /// <param name="uMsg">The message.</param>
    /// <param name="wParam">Additional message information. The content of this parameter depends on the value of the Msg parameter.</param>
    /// <param name="lParam">Additional message information. The content of this parameter depends on the value of the Msg parameter.</param>
    /// <returns>
    /// The return value is the result of the message processing and depends on the message.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-defwindowprocw
    /// </remarks>
    [DllImport("user32.dll")]
    public static extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);

    /// <summary>
    /// A callback function, which you define in your application, that processes messages sent to a window.
    /// </summary>
    /// <param name="hWnd">A handle to the window. This parameter is typically named hWnd.</param>
    /// <param name="msg">The message. This parameter is typically named uMsg.</param>
    /// <param name="wParam">Additional message information. This parameter is typically named wParam.</param>
    /// <param name="lParam">Additional message information. This parameter is typically named lParam.</param>
    /// <returns>
    /// The return value is the result of the message processing, and depends on the message sent.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nc-winuser-wndproc
    /// </remarks>
    public delegate IntPtr WNDPROC(
        IntPtr hWnd,
        uint msg,
        IntPtr wParam,
        IntPtr lParam
    );

    #endregion

    #region Messages and Message Queues / Message Refernece / Message Functions
    // see https://learn.microsoft.com/en-us/windows/win32/winmsg/message-and-message-queue-functions

    /// <summary>
    /// Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function.
    /// </summary>
    /// <param name="lpmsg">A pointer to a structure that contains the message.</param>
    /// <returns>
    /// The return value specifies the value returned by the window procedure.
    /// Although its meaning depends on the message being dispatched, the return value generally is ignored.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessage
    /// </remarks>
    [DllImport("user32.dll")]
    public static extern IntPtr DispatchMessage(
        [In] ref MSG lpmsg
    );

    /// <summary>
    /// Retrieves a message from the calling thread's message queue.
    /// The function dispatches incoming sent messages until a posted message is available for retrieval.
    /// </summary>
    /// <param name="lpMsg">A pointer to an MSG structure that receives message information from the thread's message queue.</param>
    /// <param name="hWnd">A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</param>
    /// <param name="wMsgFilterMin">The integer value of the lowest message value to be retrieved.</param>
    /// <param name="wMsgFilterMax">The integer value of the highest message value to be retrieved.</param>
    /// <returns>
    /// If the function retrieves a message other than WM_QUIT, the return value is nonzero.
    /// If the function retrieves the WM_QUIT message, the return value is zero.
    /// If there is an error, the return value is -1.
    /// For example, the function fails if hWnd is an invalid window handle or lpMsg is an invalid pointer.
    /// To get extended error information, call GetLastError.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage
    /// </remarks>
    [DllImport("user32.dll", SetLastError = false)]
    public static extern int GetMessage(
        out MSG lpMsg,
        IntPtr hWnd,
        uint wMsgFilterMin,
        uint wMsgFilterMax
    );

    #region PeekMessage

    /// <summary>
    /// Dispatches incoming nonqueued messages, checks the thread message queue for a
    /// posted message, and retrieves the message (if any exist).
    /// </summary>
    /// <param name="lpMsg">A pointer to an MSG structure that receives message information.</param>
    /// <param name="hWnd">A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</param>
    /// <param name="wMsgFilterMin">The value of the first message in the range of messages to be examined.</param>
    /// <param name="wMsgFilterMax">The value of the last message in the range of messages to be examined.</param>
    /// <param name="wRemoveMsg">Specifies how messages are to be handled. </param>
    /// <returns>
    /// If a message is available, the return value is nonzero.
    /// If no messages are available, the return value is zero.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-peekmessagea
    /// </remarks>
    [DllImport("user32.dll", SetLastError = false)]
    public static extern int PeekMessage(
        out MSG lpMsg,
        IntPtr hWnd,
        uint wMsgFilterMin,
        uint wMsgFilterMax,
        uint wRemoveMsg
    );

    /// <summary>
    /// Messages are not removed from the queue after processing by PeekMessage.
    /// </summary>
    public const uint PM_NOREMOVE = 0x0000;

    /// <summary>
    /// Messages are removed from the queue after processing by PeekMessage.
    /// </summary>
    public const uint PM_REMOVE = 0x0001;

    /// <summary>
    /// Prevents the system from releasing any thread that is waiting for the caller to go idle (see WaitForInputIdle).
    /// Combine this value with either PM_NOREMOVE or PM_REMOVE.
    /// </summary>
    public const uint PM_NOYIELD = 0x0002;

    #endregion

    /// <summary>
    /// Places (posts) a message in the message queue associated with the thread that created the
    /// specified window and returns without waiting for the thread to process the message.
    ///
    /// To post a message in the message queue associated with a thread, use the PostThreadMessage function.
    /// </summary>
    /// <param name="hWnd">A handle to the window whose window procedure is to receive the message.</param>
    /// <param name="Msg">The message to be posted.</param>
    /// <param name="wParam">Additional message-specific information.</param>
    /// <param name="lParam">Additional message-specific information.</param>
    /// <returns>
    /// If the function succeeds, the return value is nonzero.
    /// If the function fails, the return value is zero.
    /// To get extended error information, call GetLastError.
    /// GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the limit is hit.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postmessagew
    /// </remarks>
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern void PostMessage(
        int hWnd,
        uint Msg,
        IntPtr wParam,
        IntPtr lParam
    );

    /// <summary>
    /// Indicates to the system that a thread has made a request to terminate (quit).
    /// It is typically used in response to a WM_DESTROY message.
    /// </summary>
    /// <param name="nExitCode">The application exit code. This value is used as the wParam parameter of the WM_QUIT message.</param>
    /// <remarks>
    /// See hhttps://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postquitmessage
    /// </remarks>
    [DllImport("user32.dll", SetLastError = false)]
    public static extern void PostQuitMessage(
        int nExitCode
    );

    /// <summary>
    /// Posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message.
    /// </summary>
    /// <param name="idThread">The identifier of the thread to which the message is to be posted.</param>
    /// <param name="Msg">The type of message to be posted.</param>
    /// <param name="wParam">Additional message-specific information.</param>
    /// <param name="lParam">Additional message-specific information.</param>
    /// <returns>
    /// If the function succeeds, the return value is nonzero.
    /// If the function fails, the return value is zero.
    /// To get extended error information, call GetLastError.GetLastError returns ERROR_INVALID_THREAD_ID
    /// if idThread is not a valid thread identifier, or if the thread specified by idThread does not have
    /// a message queue.GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the message limit is hit.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postmessagew
    /// </remarks>
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern int PostThreadMessage(
        int idThread,
        uint Msg,
        IntPtr wParam,
        IntPtr lParam
    );

    /// <summary>
    /// Translates virtual-key messages into character messages.
    /// </summary>
    /// <param name="lpMsg"></param>
    /// <returns>
    /// If the message is translated (that is, a character message is posted to the thread's message queue), the return value is nonzero.
    /// If the message is WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, or WM_SYSKEYUP, the return value is nonzero, regardless of the translation.
    /// If the message is not translated (that is, a character message is not posted to the thread's message queue), the return value is zero.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage
    /// </remarks>
    [DllImport("user32.dll", SetLastError = false)]
    public static extern int TranslateMessage(
        [In] ref MSG lpMsg
    );

    /// <summary>
    /// Yields control to other threads when a thread has no other messages in its message queue.
    /// The WaitMessage function suspends the thread and does not return until a new message is placed in the thread's message queue.
    /// </summary>
    /// <returns>
    /// If the function succeeds, the return value is nonzero.
    /// If the function fails, the return value is zero.To get extended error information, call GetLastError.
    /// </returns>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-waitmessage
    /// </remarks>
    [DllImport("user32.dll", SetLastError = true)]
    public static extern int WaitMessage();

    #endregion

    #region Messages and Message Queues / Message Reference / Message Structures
    // see https://learn.microsoft.com/en-us/windows/win32/winmsg/message-and-message-queue-structures

    /// <summary>
    /// Contains message information from a thread's message queue.
    /// </summary>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-msg
    /// </remarks>
    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    {
        public IntPtr hwnd;
        public uint message;
        public IntPtr wParam;
        public IntPtr lParam;
        public int time;
        public Windef.POINT pt;
        public int lPrivate;
    }

    #endregion

    #endregion

    #region Learn / Windows / Apps / Win32 / Desktop Technologies / Graphics and Gaming / Windows GDI
    // see https://learn.microsoft.com/en-us/windows/win32/gdi/windows-gdi

    #region Painting and Drawing / Painting and Drawing Reference / Painting and Drawing Messages
    // see https://learn.microsoft.com/en-us/windows/win32/gdi/painting-and-drawing-messages

    /// <summary>
    /// The WM_NCPAINT message is sent to a window when its frame must be painted.
    /// </summary>
    public const uint WM_NCPAINT = 0x0085;

    /// <summary>
    /// The WM_PAINT message is sent when the system or another application makes a request
    /// to paint a portion of an application's window. The message is sent when the UpdateWindow
    /// or RedrawWindow function is called, or by the DispatchMessage function when the
    /// application obtains a WM_PAINT message by using the GetMessage or PeekMessage function.
    /// </summary>
    public const uint WM_PAINT = 0x000f;

    #endregion

    #endregion

}
